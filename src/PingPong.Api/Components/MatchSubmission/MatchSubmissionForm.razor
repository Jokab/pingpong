<MudPaper Elevation="1" Class="pa-4 form-card">
    <MudStack Spacing="2">
        <MudText Typo="Typo.h5" Class="font-weight-semibold">Registrera match</MudText>
        <MudText Typo="Typo.body2" Color="Color.Secondary">
            Logga slutresultatet direkt efter matchen så hålls tabellen aktuell.
        </MudText>

        <MudDivider />

        <MudAutocomplete Value="_model.PlayerOne" ValueChanged="@((string? sel) => OnPlayerSelected(sel, isPlayerOne: true))" Label="Spelare ett" Dense="true"
                         SearchFunc="@((string value, CancellationToken token) => SearchPlayersAsync(value, token))" ToStringFunc="(s) => s"
                         ResetValueOnEmptyText="false" Clearable="true"
                         CoerceText="true" Immediate="true">
            <ItemTemplate Context="person">
                <MudStack Row="true" AlignItems="AlignItems.Center" Spacing="1">
                    <MudIcon Icon="@Icons.Material.Filled.Person" Size="Size.Small" />
                    <MudText>@person</MudText>
                </MudStack>
            </ItemTemplate>
            <AfterItemsTemplate>
                @if (!string.IsNullOrWhiteSpace(_lastQuery) && _lastTopScore < 0.9)
                {
                    <MudListItem T="string" OnClick="@(() => AddNewPlayerAsync(isPlayerOne: true))">
                        <MudIcon Icon="@Icons.Material.Filled.PersonAdd" Class="mr-2" />
                        Lägg till '@_lastQuery'
                    </MudListItem>
                }
            </AfterItemsTemplate>
        </MudAutocomplete>

        @if (_suggestions.Count > 0)
        {
            <MudStack Spacing="1">
                <MudText Typo="Typo.subtitle2">Snabbval</MudText>
                <MudStack Row="true" Spacing="1">
                    @foreach (var s in _suggestions)
                    {
                        <MudChip T="string" OnClick="@(() => { _model.PlayerTwo = s.displayName; StateHasChanged(); })">
                            @s.displayName
                        </MudChip>
                    }
                </MudStack>
            </MudStack>
        }

        <MudAutocomplete Value="_model.PlayerTwo" ValueChanged="@((string? sel) => OnPlayerSelected(sel, isPlayerOne: false))" Label="Spelare två" Dense="true"
                         SearchFunc="@((string value, CancellationToken token) => SearchPlayersAsync(value, token))" ToStringFunc="(s) => s"
                         ResetValueOnEmptyText="false" Clearable="true"
                         CoerceText="true" Immediate="true">
            <ItemTemplate Context="person">
                <MudStack Row="true" AlignItems="AlignItems.Center" Spacing="1">
                    <MudIcon Icon="@Icons.Material.Filled.Person" Size="Size.Small" />
                    <MudText>@person</MudText>
                </MudStack>
            </ItemTemplate>
            <AfterItemsTemplate>
                @if (!string.IsNullOrWhiteSpace(_lastQuery) && _lastTopScore < 0.9)
                {
                    <MudListItem T="string" OnClick="@(() => AddNewPlayerAsync(isPlayerOne: false))">
                        <MudIcon Icon="@Icons.Material.Filled.PersonAdd" Class="mr-2" />
                        Lägg till '@_lastQuery'
                    </MudListItem>
                }
            </AfterItemsTemplate>
        </MudAutocomplete>

        <MudDatePicker Label="Matchdatum" @bind-Date="_model.MatchDate" />

        @if (QuickEnabled)
        {
            <MudStack Row="true" Spacing="1">
                <MudButton Variant="Variant.Filled" Color="Color.Success" OnClick="@(() => QuickSubmitAsync(true))" StartIcon="@Icons.Material.Filled.ThumbUp">
                    Jag vann
                </MudButton>
                <MudButton Variant="Variant.Outlined" Color="Color.Error" OnClick="@(() => QuickSubmitAsync(false))" StartIcon="@Icons.Material.Filled.ThumbDown">
                    Jag förlorade
                </MudButton>
            </MudStack>
        }

        <MudStack Spacing="1">
            <MudPaper Class="pa-2">
                <MudStack Spacing="1">
                    @foreach (var set in _model.Sets)
                    {
                        <MudGrid>
                            <MudItem xs="12" sm="4">
                                <MudText Typo="Typo.subtitle2">Set @set.Number</MudText>
                            </MudItem>
                            <MudItem xs="12" sm="4">
                                <MudNumericField @bind-Value="set.PlayerOneScore" Label="Spelare ett" Min="0" />
                            </MudItem>
                            <MudItem xs="12" sm="4">
                                <MudNumericField @bind-Value="set.PlayerTwoScore" Label="Spelare två" Min="0" />
                            </MudItem>
                        </MudGrid>
                        <MudDivider Class="my-1" />
                    }

                    <MudStack Row="true" Justify="Justify.FlexStart" Spacing="1">
                        <MudButton Variant="Variant.Outlined" Color="Color.Primary" OnClick="AddSet" StartIcon="@Icons.Material.Filled.Add">
                            Lägg till set
                        </MudButton>
                        <MudButton Variant="Variant.Outlined" Color="Color.Secondary" Disabled="_model.Sets.Count <= 1"
                                   OnClick="RemoveSet" StartIcon="@Icons.Material.Filled.Remove">
                            Ta bort set
                        </MudButton>
                    </MudStack>
                </MudStack>
            </MudPaper>
        </MudStack>

        @if (!string.IsNullOrWhiteSpace(_error))
        {
            <MudAlert Severity="Severity.Error" Dense="true">
                @_error
            </MudAlert>
        }

        <MudButton Variant="Variant.Filled" Color="Color.Primary"
                   Disabled="_isSubmitting" StartIcon="@Icons.Material.Filled.Send"
                   OnClick="@SubmitAsync">
            @(_isSubmitting ? "Skickar..." : "Skicka")
        </MudButton>
    </MudStack>
</MudPaper>

@implements IDisposable

@code {
    [Parameter]
    public EventCallback OnSubmitted { get; set; }

    [Inject]
    private HttpClient Http { get; set; } = default!;

    [Inject]
    private ISnackbar Snackbar { get; set; } = default!;

    [Inject]
    private UserIdentityService IdentityService { get; set; } = default!;

    private string? _lastQuery;
    private double _lastTopScore;

    private readonly MatchSubmissionDraft _model = new();
    private bool _isSubmitting;
    private string? _error;
    private bool _hasPrefilledIdentity;
    private string? _identityName;
    private List<Suggestion> _suggestions = new();

    protected override async Task OnInitializedAsync()
    {
        if (_model.Sets.Count == 0)
        {
            for (var i = 0; i < 3; i++)
            {
                AddSet();
            }
        }
        
        // Förifyll spelare ett med identitet från localStorage
        await LoadIdentityAsync();
        
        // Subscribe to identity changes
        IdentityService.IdentityChanged += OnIdentityChanged;
        // await LoadSuggestionsAsync();
    }

    private async Task LoadIdentityAsync()
    {
        var identityName = await IdentityService.GetIdentityNameAsync();
        _identityName = identityName;
        if (string.IsNullOrWhiteSpace(_model.PlayerOne) && !_hasPrefilledIdentity)
        {
            if (!string.IsNullOrWhiteSpace(identityName))
            {
                _model.PlayerOne = identityName;
                _hasPrefilledIdentity = true;
            }
        }
    }

    private async void OnIdentityChanged(object? sender, EventArgs e)
    {
        // Only update if user hasn't manually changed PlayerOne
        if (_hasPrefilledIdentity && string.IsNullOrWhiteSpace(_model.PlayerOne))
        {
            var identityName = await IdentityService.GetIdentityNameAsync();
            _identityName = identityName;
            if (!string.IsNullOrWhiteSpace(identityName))
            {
                _model.PlayerOne = identityName;
                await InvokeAsync(StateHasChanged);
            }
        }
    }

    public void Dispose()
    {
        IdentityService.IdentityChanged -= OnIdentityChanged;
    }

    private async Task<IEnumerable<string?>> SearchPlayersAsync(string value, CancellationToken cancellationToken)
    {
        _lastQuery = value?.Trim();
        _lastTopScore = 0;
        if (string.IsNullOrWhiteSpace(_lastQuery) || _lastQuery!.Length < 2)
        {
            return Array.Empty<string?>();
        }

        var resp = await Http.GetFromJsonAsync<List<PlayerSuggestion>>($"/api/players?query={Uri.EscapeDataString(_lastQuery)}&size=10", cancellationToken);
        var items = resp ?? new List<PlayerSuggestion>();
        _lastTopScore = items.Count > 0 ? items[0].score : 0;
        var names = items.Select(i => i.displayName).ToList<string?>();
        if (names.Count == 0)
        {
            names.Add(" "); // placeholder item so popup opens and AfterItemsTemplate Add button is visible
        }
        return names;
    }

    private void AddSet()
    {
        var nextNumber = _model.Sets.Count + 1;
        _model.Sets.Add(new SetDraft(nextNumber));
    }

    private void RemoveSet()
    {
        if (_model.Sets.Count > 1)
        {
            _model.Sets.RemoveAt(_model.Sets.Count - 1);
        }
    }

    private async Task LoadSuggestionsAsync()
    {
        try
        {
            var me = _identityName;
            var url = string.IsNullOrWhiteSpace(me)
                ? "/api/suggestions/opponents?take=5"
                : $"/api/suggestions/opponents?me={Uri.EscapeDataString(me)}&take=5";
            var resp = await Http.GetFromJsonAsync<SuggestionsResponse>(url);
            _suggestions = resp?.items ?? new List<Suggestion>();
        }
        catch
        {
            _suggestions.Clear();
        }
        StateHasChanged();
    }

    private bool QuickEnabled
    {
        get
        {
            if (string.IsNullOrWhiteSpace(_identityName)) return false;
            var p1 = _model.PlayerOne?.Trim();
            var p2 = _model.PlayerTwo?.Trim();
            if (string.IsNullOrWhiteSpace(p1) || string.IsNullOrWhiteSpace(p2)) return false;
            if (string.Equals(p1, p2, StringComparison.OrdinalIgnoreCase)) return false;
            return string.Equals(p1, _identityName, StringComparison.OrdinalIgnoreCase) || string.Equals(p2, _identityName, StringComparison.OrdinalIgnoreCase);
        }
    }

    private async Task SubmitAsync()
    {
        if (_isSubmitting) return;
        _error = null;
        StateHasChanged();

        var p1 = _model.PlayerOne?.Trim();
        var p2 = _model.PlayerTwo?.Trim();
        if (string.IsNullOrWhiteSpace(p1) || string.IsNullOrWhiteSpace(p2))
        {
            _error = "Båda spelarnamnen krävs.";
            return;
        }
        if (string.Equals(p1, p2, StringComparison.OrdinalIgnoreCase))
        {
            _error = "Spelarna måste vara olika.";
            return;
        }
        if (_model.Sets.Count == 0)
        {
            _error = "Lägg till minst ett set.";
            return;
        }

        var sets = _model.Sets
            .Select(s => new SetScoreDto(s.PlayerOneScore, s.PlayerTwoScore))
            .ToList();

        var dto = (MatchSubmissionDto)new ScoredMatchSubmissionDto(
            p1!,
            p2!,
            _model.MatchDate.HasValue ? DateOnly.FromDateTime(_model.MatchDate.Value) : DateOnly.FromDateTime(DateTime.UtcNow),
            sets,
            "ui");

        try
        {
            _isSubmitting = true;
            StateHasChanged();
            var response = await Http.PostAsJsonAsync("/matches", dto);
            var body = await response.Content.ReadAsStringAsync();
            if (!response.IsSuccessStatusCode)
            {
                _error = $"Sändning misslyckades: {body}";
                Snackbar.Add(_error, Severity.Error);
                return;
            }

            Snackbar.Add("Match inskickad!", Severity.Success);
            await OnSubmitted.InvokeAsync();

            // Reset simple fields but keep players for consecutive matches
            _model.Sets.Clear();
            for (var i = 0; i < 3; i++) AddSet();
        }
        catch (Exception ex)
        {
            _error = $"Oväntat fel: {ex.Message}";
            Snackbar.Add(_error, Severity.Error);
        }
        finally
        {
            _isSubmitting = false;
            StateHasChanged();
        }
    }

    private sealed class MatchSubmissionDraft
    {
        public string? PlayerOne { get; set; }

        public string? PlayerTwo { get; set; }

        public DateTime? MatchDate { get; set; } = DateTime.Today;

        public List<SetDraft> Sets { get; } = new();
    }

    private sealed class SetDraft
    {
        public SetDraft(int number)
        {
            Number = number;
        }

        public int Number { get; }

        public int PlayerOneScore { get; set; }

        public int PlayerTwoScore { get; set; }
    }
    private async Task AddNewPlayerAsync(bool isPlayerOne)
    {
        if (string.IsNullOrWhiteSpace(_lastQuery)) return;
        var payload = new PlayerCreate(_lastQuery!);
        var response = await Http.PostAsJsonAsync("/api/players", payload);
        response.EnsureSuccessStatusCode();
        var created = await response.Content.ReadFromJsonAsync<PlayerCreated>();
        if (created is null) return;
        if (isPlayerOne) _model.PlayerOne = created.displayName; else _model.PlayerTwo = created.displayName;
        Snackbar.Add($"La till spelare '{created.displayName}'", Severity.Success);
        StateHasChanged();
    }

    private async Task OnPlayerSelected(string? selection, bool isPlayerOne)
    {
        // Handle clearing
        if (string.IsNullOrWhiteSpace(selection))
        {
            if (isPlayerOne)
            {
                _model.PlayerOne = null;
                _hasPrefilledIdentity = false; // User intentionally cleared, don't auto-refill
            }
            else
            {
                _model.PlayerTwo = null;
            }
            return;
        }
        
        if (selection.Trim().Length == 0) return; // ignore placeholder
        
        // Detect synthetic add item
        if (selection.StartsWith("Lägg till '") && selection.EndsWith("'", StringComparison.Ordinal))
        {
            // re-use last query to create
            await AddNewPlayerAsync(isPlayerOne);
            return;
        }

        if (isPlayerOne) _model.PlayerOne = selection; else _model.PlayerTwo = selection;
    }

    private sealed record PlayerSuggestion(Guid id, string displayName, double score, bool isExact);
    private sealed record PlayerCreate(string DisplayName);
    private sealed record PlayerCreated(Guid id, string displayName);
    private sealed record Suggestion(Guid id, string displayName, int count);
    private sealed record SuggestionsResponse(List<Suggestion> items);

    private async Task QuickSubmitAsync(bool iWon)
    {
        if (_isSubmitting) return;
        _error = null;
        StateHasChanged();

        var p1 = _model.PlayerOne?.Trim();
        var p2 = _model.PlayerTwo?.Trim();
        if (string.IsNullOrWhiteSpace(p1) || string.IsNullOrWhiteSpace(p2))
        {
            _error = "Båda spelarnamnen krävs.";
            return;
        }
        if (string.Equals(p1, p2, StringComparison.OrdinalIgnoreCase))
        {
            _error = "Spelarna måste vara olika.";
            return;
        }

        var meIsP1 = string.Equals(p1, _identityName, StringComparison.OrdinalIgnoreCase);
        var playerOneWon = meIsP1 ? iWon : !iWon;
        var dto = (MatchSubmissionDto)new OutcomeOnlyMatchSubmissionDto(
            p1!,
            p2!,
            _model.MatchDate.HasValue ? DateOnly.FromDateTime(_model.MatchDate.Value) : DateOnly.FromDateTime(DateTime.UtcNow),
            playerOneWon,
            "ui");

        try
        {
            _isSubmitting = true;
            StateHasChanged();
            var response = await Http.PostAsJsonAsync("/matches", dto);
            var body = await response.Content.ReadAsStringAsync();
            if (!response.IsSuccessStatusCode)
            {
                _error = $"Sändning misslyckades: {body}";
                Snackbar.Add(_error, Severity.Error);
                return;
            }
            Snackbar.Add("Match inskickad!", Severity.Success);
            await OnSubmitted.InvokeAsync();
        }
        catch (Exception ex)
        {
            _error = $"Oväntat fel: {ex.Message}";
            Snackbar.Add(_error, Severity.Error);
        }
        finally
        {
            _isSubmitting = false;
            StateHasChanged();
        }
    }
}
