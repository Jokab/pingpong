<MudPaper Elevation="1" Class="pa-4 form-card">
    <MudStack Spacing="2">
        <MudText Typo="Typo.h5" Class="font-weight-semibold">Registrera match</MudText>
        <MudText Typo="Typo.body2" Color="Color.Secondary">
            Logga slutresultatet direkt efter matchen så hålls tabellen aktuell.
        </MudText>

        <MudDivider />

        <MudAutocomplete Value="_model.PlayerOne" ValueChanged="@((string? sel) => OnPlayerSelected(sel, isPlayerOne: true))" Label="Spelare ett" Dense="true"
                         SearchFunc="@((string value, CancellationToken token) => SearchPlayersAsync(value, token))" ToStringFunc="(s) => s"
                         ResetValueOnEmptyText="false" Clearable="true"
                         CoerceText="true" Immediate="true">
            <ItemTemplate Context="person">
                <MudStack Row="true" AlignItems="AlignItems.Center" Spacing="1">
                    <MudIcon Icon="@Icons.Material.Filled.Person" Size="Size.Small" />
                    <MudText>@person</MudText>
                </MudStack>
            </ItemTemplate>
            <AfterItemsTemplate>
                @if (!string.IsNullOrWhiteSpace(_lastQuery) && _lastTopScore < 0.9)
                {
                    <MudListItem T="string" OnClick="@(() => AddNewPlayerAsync(isPlayerOne: true))">
                        <MudIcon Icon="@Icons.Material.Filled.PersonAdd" Class="mr-2" />
                        Lägg till '@_lastQuery'
                    </MudListItem>
                }
            </AfterItemsTemplate>
        </MudAutocomplete>

        @if (_suggestions.Count > 0)
        {
            <MudStack Spacing="1">
                <MudText Typo="Typo.subtitle2">Snabbval</MudText>
                <MudStack Row="true" Spacing="1">
                    @foreach (var s in _suggestions)
                    {
                        <MudChip T="string" OnClick="@(() => { _model.PlayerTwo = s.displayName; StateHasChanged(); })">
                            @s.displayName
                        </MudChip>
                    }
                </MudStack>
            </MudStack>
        }

        <MudAutocomplete Value="_model.PlayerTwo" ValueChanged="@((string? sel) => OnPlayerSelected(sel, isPlayerOne: false))" Label="Spelare två" Dense="true"
                         SearchFunc="@((string value, CancellationToken token) => SearchPlayersAsync(value, token))" ToStringFunc="(s) => s"
                         ResetValueOnEmptyText="false" Clearable="true"
                         CoerceText="true" Immediate="true">
            <ItemTemplate Context="person">
                <MudStack Row="true" AlignItems="AlignItems.Center" Spacing="1">
                    <MudIcon Icon="@Icons.Material.Filled.Person" Size="Size.Small" />
                    <MudText>@person</MudText>
                </MudStack>
            </ItemTemplate>
            <AfterItemsTemplate>
                @if (!string.IsNullOrWhiteSpace(_lastQuery) && _lastTopScore < 0.9)
                {
                    <MudListItem T="string" OnClick="@(() => AddNewPlayerAsync(isPlayerOne: false))">
                        <MudIcon Icon="@Icons.Material.Filled.PersonAdd" Class="mr-2" />
                        Lägg till '@_lastQuery'
                    </MudListItem>
                }
            </AfterItemsTemplate>
        </MudAutocomplete>

        <MudDatePicker Label="Matchdatum"
                       @bind-Date="_model.MatchDate"
                       DateFormat="yyyy-MM-dd"
                       Culture="@SwedishCulture" />

        <MudStack Spacing="1">
            <MudText Typo="Typo.subtitle2">Typ av match</MudText>
            <MudButtonGroup Color="Color.Primary">
                <MudButton Variant="@(_submissionMode == SubmissionMode.OutcomeOnly ? Variant.Filled : Variant.Outlined)" 
                          OnClick="@(() => OnSubmissionModeChanged(SubmissionMode.OutcomeOnly))">
                    Endast resultat
                </MudButton>
                <MudButton Variant="@(_submissionMode == SubmissionMode.Scored ? Variant.Filled : Variant.Outlined)" 
                          OnClick="@(() => OnSubmissionModeChanged(SubmissionMode.Scored))">
                    Med set-poäng
                </MudButton>
            </MudButtonGroup>
        </MudStack>

        @if (_submissionMode == SubmissionMode.OutcomeOnly)
        {
            <MudStack Spacing="1">
                <MudText Typo="Typo.subtitle2">Vinnare</MudText>
                <MudRadioGroup T="Winner" selectedOption="_selectedWinner" selectedOptionChanged="@((Winner w) => { _selectedWinner = w; _model.Winner = w; StateHasChanged(); })">
                    <MudRadio T="Winner" option="@Winner.PlayerOne" Color="Color.Primary">@(_model.PlayerOne ?? "Spelare ett")</MudRadio>
                    <MudRadio T="Winner" option="@Winner.PlayerTwo" Color="Color.Primary">@(_model.PlayerTwo ?? "Spelare två")</MudRadio>
                </MudRadioGroup>
            </MudStack>
        }
        else
        {
            <MudStack Spacing="1">
                <MudPaper Class="pa-2">
                    <MudStack Spacing="1">
                        @foreach (var set in _model.Sets)
                        {
                            <MudGrid>
                                <MudItem xs="12" sm="4">
                                    <MudText Typo="Typo.subtitle2">Set @set.Number</MudText>
                                </MudItem>
                                <MudItem xs="12" sm="4">
                                    <MudNumericField @bind-Value="set.PlayerOneScore" Label="Spelare ett" Min="0" />
                                </MudItem>
                                <MudItem xs="12" sm="4">
                                    <MudNumericField @bind-Value="set.PlayerTwoScore" Label="Spelare två" Min="0" />
                                </MudItem>
                            </MudGrid>
                            <MudDivider Class="my-1" />
                        }

                        <MudStack Row="true" Justify="Justify.FlexStart" Spacing="1">
                            <MudButton Variant="Variant.Outlined" Color="Color.Primary" OnClick="AddSet" StartIcon="@Icons.Material.Filled.Add">
                                Lägg till set
                            </MudButton>
                            <MudButton Variant="Variant.Outlined" Color="Color.Secondary" Disabled="_model.Sets.Count <= 1"
                                       OnClick="RemoveSet" StartIcon="@Icons.Material.Filled.Remove">
                                Ta bort set
                            </MudButton>
                        </MudStack>
                    </MudStack>
                </MudPaper>
            </MudStack>
        }

        @if (!string.IsNullOrWhiteSpace(_error))
        {
            <MudAlert Severity="Severity.Error" Dense="true">
                @_error
            </MudAlert>
        }

        <MudButton Variant="Variant.Filled" Color="Color.Primary"
                   Disabled="_isSubmitting" StartIcon="@Icons.Material.Filled.Send"
                   OnClick="@SubmitAsync">
            @(_isSubmitting ? "Skickar..." : "Skicka")
        </MudButton>
    </MudStack>
</MudPaper>

@implements IDisposable

@code {
    [Parameter]
    public EventCallback OnSubmitted { get; set; }

    [Inject]
    private HttpClient Http { get; set; } = default!;

    [Inject]
    private ISnackbar Snackbar { get; set; } = default!;

    [Inject]
    private UserIdentityService IdentityService { get; set; } = default!;

    private string? _lastQuery;
    private double _lastTopScore;

    private readonly MatchSubmissionDraft _model = new();
    private bool _isSubmitting;
    private string? _error;
    private bool _hasPrefilledIdentity;
    private string? _identityName;
    private List<Suggestion> _suggestions = new();
    private SubmissionMode _submissionMode = SubmissionMode.OutcomeOnly;
    private Winner _selectedWinner = Winner.PlayerOne; // UI binding value, defaults to PlayerOne for display
    private static readonly CultureInfo SwedishCulture = CultureInfo.GetCultureInfo("sv-SE");

    protected override async Task OnInitializedAsync()
    {
        // Only initialize sets if we're in scored mode
        if (_submissionMode == SubmissionMode.Scored && _model.Sets.Count == 0)
        {
            for (var i = 0; i < 3; i++)
            {
                AddSet();
            }
        }
        
        // Förifyll spelare ett med identitet från localStorage
        await LoadIdentityAsync();
        
        // Subscribe to identity changes
        IdentityService.IdentityChanged += OnIdentityChanged;
        // await LoadSuggestionsAsync();
    }

    private async Task LoadIdentityAsync()
    {
        var identityName = await IdentityService.GetIdentityNameAsync();
        _identityName = identityName;
        if (string.IsNullOrWhiteSpace(_model.PlayerOne) && !_hasPrefilledIdentity)
        {
            if (!string.IsNullOrWhiteSpace(identityName))
            {
                _model.PlayerOne = identityName;
                _hasPrefilledIdentity = true;
            }
        }
    }

    private async void OnIdentityChanged(object? sender, EventArgs e)
    {
        // Only update if user hasn't manually changed PlayerOne
        if (_hasPrefilledIdentity && string.IsNullOrWhiteSpace(_model.PlayerOne))
        {
            var identityName = await IdentityService.GetIdentityNameAsync();
            _identityName = identityName;
            if (!string.IsNullOrWhiteSpace(identityName))
            {
                _model.PlayerOne = identityName;
                await InvokeAsync(StateHasChanged);
            }
        }
    }

    public void Dispose()
    {
        IdentityService.IdentityChanged -= OnIdentityChanged;
    }

    private async Task<IEnumerable<string?>> SearchPlayersAsync(string value, CancellationToken cancellationToken)
    {
        _lastQuery = value?.Trim();
        _lastTopScore = 0;
        if (string.IsNullOrWhiteSpace(_lastQuery) || _lastQuery!.Length < 2)
        {
            return Array.Empty<string?>();
        }

        var resp = await Http.GetFromJsonAsync<List<PlayerSuggestion>>($"/api/players?query={Uri.EscapeDataString(_lastQuery)}&size=10", cancellationToken);
        var items = resp ?? new List<PlayerSuggestion>();
        _lastTopScore = items.Count > 0 ? items[0].score : 0;
        var names = items.Select(i => i.displayName).ToList<string?>();
        if (names.Count == 0)
        {
            names.Add(" "); // placeholder item so popup opens and AfterItemsTemplate Add button is visible
        }
        return names;
    }

    private void AddSet()
    {
        var nextNumber = _model.Sets.Count + 1;
        _model.Sets.Add(new SetDraft(nextNumber));
    }

    private void OnSubmissionModeChanged(SubmissionMode mode)
    {
        if (_submissionMode == mode) return;
        
        _submissionMode = mode;
        if (_submissionMode == SubmissionMode.Scored && _model.Sets.Count == 0)
        {
            // Initialize sets when switching to scored mode
            for (var i = 0; i < 3; i++)
            {
                AddSet();
            }
        }
        else if (_submissionMode == SubmissionMode.OutcomeOnly)
        {
            // Clear sets when switching to outcome-only mode
            _model.Sets.Clear();
        }
        StateHasChanged();
    }


    private void RemoveSet()
    {
        if (_model.Sets.Count > 1)
        {
            _model.Sets.RemoveAt(_model.Sets.Count - 1);
        }
    }

    private async Task LoadSuggestionsAsync()
    {
        try
        {
            var me = _identityName;
            var url = string.IsNullOrWhiteSpace(me)
                ? "/api/suggestions/opponents?take=5"
                : $"/api/suggestions/opponents?me={Uri.EscapeDataString(me)}&take=5";
            var resp = await Http.GetFromJsonAsync<SuggestionsResponse>(url);
            _suggestions = resp?.items ?? new List<Suggestion>();
        }
        catch
        {
            _suggestions.Clear();
        }
        StateHasChanged();
    }

    private async Task SubmitAsync()
    {
        if (_isSubmitting) return;
        _error = null;
        StateHasChanged();

        var p1 = _model.PlayerOne?.Trim();
        var p2 = _model.PlayerTwo?.Trim();
        if (string.IsNullOrWhiteSpace(p1) || string.IsNullOrWhiteSpace(p2))
        {
            _error = "Båda spelarnamnen krävs.";
            return;
        }
        if (string.Equals(p1, p2, StringComparison.OrdinalIgnoreCase))
        {
            _error = "Spelarna måste vara olika.";
            return;
        }

        MatchSubmissionDto dto;
        var submitterName = await IdentityService.GetIdentityNameAsync();
        var submittedBy = string.IsNullOrWhiteSpace(submitterName) ? "anonym" : submitterName!.Trim();

        if (_submissionMode == SubmissionMode.OutcomeOnly)
        {
            // Use _selectedWinner which is always set (defaults to PlayerOne)
            // _model.Winner is set when user interacts, but we can also use _selectedWinner directly
            var playerOneWon = _selectedWinner == Winner.PlayerOne;
            dto = (MatchSubmissionDto)new OutcomeOnlyMatchSubmissionDto(
                p1!,
                p2!,
                _model.MatchDate.HasValue ? DateOnly.FromDateTime(_model.MatchDate.Value) : DateOnly.FromDateTime(DateTime.UtcNow),
                playerOneWon,
                Sets: null,
                SubmittedBy: submittedBy);
        }
        else
        {
            if (_model.Sets.Count == 0)
            {
                _error = "Lägg till minst ett set.";
                return;
            }

            var sets = _model.Sets
                .Select(s => new SetScoreDto(s.PlayerOneScore, s.PlayerTwoScore))
                .ToList();

            dto = (MatchSubmissionDto)new ScoredMatchSubmissionDto(
                p1!,
                p2!,
                _model.MatchDate.HasValue ? DateOnly.FromDateTime(_model.MatchDate.Value) : DateOnly.FromDateTime(DateTime.UtcNow),
                sets,
                submittedBy);
        }

        try
        {
            _isSubmitting = true;
            StateHasChanged();
            var response = await Http.PostAsJsonAsync("/matches", dto);
            var body = await response.Content.ReadAsStringAsync();
            if (!response.IsSuccessStatusCode)
            {
                _error = $"Sändning misslyckades: {body}";
                Snackbar.Add(_error, Severity.Error);
                return;
            }

            Snackbar.Add("Match inskickad!", Severity.Success);
            await OnSubmitted.InvokeAsync();

            // Reset form but keep players for consecutive matches
            _model.Winner = null;
            _selectedWinner = Winner.PlayerOne;
            _model.Sets.Clear();
            if (_submissionMode == SubmissionMode.Scored)
            {
                for (var i = 0; i < 3; i++) AddSet();
            }
        }
        catch (Exception ex)
        {
            _error = $"Oväntat fel: {ex.Message}";
            Snackbar.Add(_error, Severity.Error);
        }
        finally
        {
            _isSubmitting = false;
            StateHasChanged();
        }
    }

    private sealed class MatchSubmissionDraft
    {
        public string? PlayerOne { get; set; }

        public string? PlayerTwo { get; set; }

        public DateTime? MatchDate { get; set; } = DateTime.Today;

        public List<SetDraft> Sets { get; } = new();

        public Winner? Winner { get; set; }
    }

    private enum SubmissionMode
    {
        OutcomeOnly,
        Scored
    }

    private enum Winner
    {
        PlayerOne,
        PlayerTwo
    }

    private sealed class SetDraft
    {
        public SetDraft(int number)
        {
            Number = number;
        }

        public int Number { get; }

        public int PlayerOneScore { get; set; }

        public int PlayerTwoScore { get; set; }
    }
    private async Task AddNewPlayerAsync(bool isPlayerOne)
    {
        if (string.IsNullOrWhiteSpace(_lastQuery)) return;
        var payload = new PlayerCreate(_lastQuery!);
        var response = await Http.PostAsJsonAsync("/api/players", payload);
        response.EnsureSuccessStatusCode();
        var created = await response.Content.ReadFromJsonAsync<PlayerCreated>();
        if (created is null) return;
        if (isPlayerOne) _model.PlayerOne = created.displayName; else _model.PlayerTwo = created.displayName;
        Snackbar.Add($"La till spelare '{created.displayName}'", Severity.Success);
        StateHasChanged();
    }

    private async Task OnPlayerSelected(string? selection, bool isPlayerOne)
    {
        // Handle clearing
        if (string.IsNullOrWhiteSpace(selection))
        {
            if (isPlayerOne)
            {
                _model.PlayerOne = null;
                _hasPrefilledIdentity = false; // User intentionally cleared, don't auto-refill
            }
            else
            {
                _model.PlayerTwo = null;
            }
            return;
        }
        
        if (selection.Trim().Length == 0) return; // ignore placeholder
        
        // Detect synthetic add item
        if (selection.StartsWith("Lägg till '") && selection.EndsWith("'", StringComparison.Ordinal))
        {
            // re-use last query to create
            await AddNewPlayerAsync(isPlayerOne);
            return;
        }

        if (isPlayerOne) _model.PlayerOne = selection; else _model.PlayerTwo = selection;
    }

    private sealed record PlayerSuggestion(Guid id, string displayName, double score, bool isExact);
    private sealed record PlayerCreate(string DisplayName);
    private sealed record PlayerCreated(Guid id, string displayName);
    private sealed record Suggestion(Guid id, string displayName, int count);
    private sealed record SuggestionsResponse(List<Suggestion> items);
}
