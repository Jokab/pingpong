<MudPaper Elevation="1" Class="pa-4 form-card">
    <MudStack Spacing="2">
        <MudText Typo="Typo.h5" Class="font-weight-semibold">Registrera match</MudText>
        <MudText Typo="Typo.body2" Color="Color.Secondary">
            Logga slutresultatet direkt efter matchen så hålls tabellen aktuell.
        </MudText>

        <MudDivider />

        <MudAutocomplete Value="_model.PlayerOne" ValueChanged="@((string? sel) => OnPlayerSelected(sel, isPlayerOne: true))" Label="Spelare ett" Dense="true"
                         SearchFunc="@((string value, CancellationToken token) => SearchPlayersAsync(value, token))" ToStringFunc="(s) => s"
                         ResetValueOnEmptyText="false" Clearable="true"
                         CoerceText="true" Immediate="true">
            <ItemTemplate Context="person">
                <MudStack Row="true" AlignItems="AlignItems.Center" Spacing="1">
                    <MudIcon Icon="@Icons.Material.Filled.Person" Size="Size.Small" />
                    <MudText>@person</MudText>
                </MudStack>
            </ItemTemplate>
            <AfterItemsTemplate>
                @if (!string.IsNullOrWhiteSpace(_lastQuery) && _lastTopScore < 0.9)
                {
                    <MudListItem T="string" OnClick="@(() => AddNewPlayerAsync(isPlayerOne: true))">
                        <MudIcon Icon="@Icons.Material.Filled.PersonAdd" Class="mr-2" />
                        Lägg till '@_lastQuery'
                    </MudListItem>
                }
            </AfterItemsTemplate>
        </MudAutocomplete>

        @if (_suggestions.Count > 0)
        {
            <MudStack Spacing="1">
                <MudText Typo="Typo.subtitle2">Snabbval</MudText>
                <MudStack Row="true" Spacing="1">
                    @foreach (var s in _suggestions)
                    {
                        <MudChip T="string" OnClick="@(() => { _model.PlayerTwo = s.displayName; StateHasChanged(); })">
                            @s.displayName
                        </MudChip>
                    }
                </MudStack>
            </MudStack>
        }

        <MudAutocomplete Value="_model.PlayerTwo" ValueChanged="@((string? sel) => OnPlayerSelected(sel, isPlayerOne: false))" Label="Spelare två" Dense="true"
                         SearchFunc="@((string value, CancellationToken token) => SearchPlayersAsync(value, token))" ToStringFunc="(s) => s"
                         ResetValueOnEmptyText="false" Clearable="true"
                         CoerceText="true" Immediate="true">
            <ItemTemplate Context="person">
                <MudStack Row="true" AlignItems="AlignItems.Center" Spacing="1">
                    <MudIcon Icon="@Icons.Material.Filled.Person" Size="Size.Small" />
                    <MudText>@person</MudText>
                </MudStack>
            </ItemTemplate>
            <AfterItemsTemplate>
                @if (!string.IsNullOrWhiteSpace(_lastQuery) && _lastTopScore < 0.9)
                {
                    <MudListItem T="string" OnClick="@(() => AddNewPlayerAsync(isPlayerOne: false))">
                        <MudIcon Icon="@Icons.Material.Filled.PersonAdd" Class="mr-2" />
                        Lägg till '@_lastQuery'
                    </MudListItem>
                }
            </AfterItemsTemplate>
        </MudAutocomplete>

        <MudDatePicker Label="Matchdatum"
                       @bind-Date="_model.MatchDate"
                       DateFormat="yyyy-MM-dd"
                       Culture="@SwedishCulture" />

        <MudStack Spacing="1">
            <MudText Typo="Typo.subtitle2">Typ av match</MudText>
            <MudButtonGroup Color="Color.Primary">
                <MudButton Variant="@(_submissionMode == SubmissionMode.OutcomeOnly ? Variant.Filled : Variant.Outlined)" 
                          OnClick="@(() => OnSubmissionModeChanged(SubmissionMode.OutcomeOnly))">
                    Endast resultat
                </MudButton>
                <MudButton Variant="@(_submissionMode == SubmissionMode.Scored ? Variant.Filled : Variant.Outlined)" 
                          OnClick="@(() => OnSubmissionModeChanged(SubmissionMode.Scored))">
                    Med set-poäng
                </MudButton>
            </MudButtonGroup>
        </MudStack>

        @if (_submissionMode == SubmissionMode.OutcomeOnly)
        {
            <MudStack Spacing="1">
                <MudText Typo="Typo.subtitle2">Setresultat</MudText>
                <MudTextField @bind-Value="_outcomeSetsInput"
                              Label="Ange antal vunna set"
                              Placeholder="t.ex. 2-1"
                              Immediate="true"
                              InputType="InputType.Text"
                              AdornmentIcon="@Icons.Material.Filled.SportsTennis"
                              AdornmentColor="Color.Primary" />
                <MudText Typo="Typo.caption" Color="Color.Secondary">
                    Formatet är &quot;spelare ett - spelare två&quot;, exempelvis 3-1. Vinnaren räknas automatiskt.
                </MudText>
                @if (TryGetOutcomePreview(out var preview))
                {
                    <MudAlert Severity="Severity.Info" Dense="true" Variant="Variant.Outlined">
                        @($"{preview.WinnerName} vann {preview.PlayerOneSets}-{preview.PlayerTwoSets}")
                    </MudAlert>
                }
            </MudStack>
        }
        else
        {
            <MudStack Spacing="1">
                <MudPaper Class="pa-2">
                    <MudStack Spacing="1">
                        @foreach (var set in _model.Sets)
                        {
                            <MudGrid>
                                <MudItem xs="12" sm="4">
                                    <MudText Typo="Typo.subtitle2">Set @set.Number</MudText>
                                </MudItem>
                                <MudItem xs="12" sm="4">
                                    <MudNumericField @bind-Value="set.PlayerOneScore" Label="Spelare ett" Min="0" />
                                </MudItem>
                                <MudItem xs="12" sm="4">
                                    <MudNumericField @bind-Value="set.PlayerTwoScore" Label="Spelare två" Min="0" />
                                </MudItem>
                            </MudGrid>
                            <MudDivider Class="my-1" />
                        }

                        <MudStack Row="true" Justify="Justify.FlexStart" Spacing="1">
                            <MudButton Variant="Variant.Outlined" Color="Color.Primary" OnClick="AddSet" StartIcon="@Icons.Material.Filled.Add">
                                Lägg till set
                            </MudButton>
                            <MudButton Variant="Variant.Outlined" Color="Color.Secondary" Disabled="_model.Sets.Count <= 1"
                                       OnClick="RemoveSet" StartIcon="@Icons.Material.Filled.Remove">
                                Ta bort set
                            </MudButton>
                        </MudStack>
                    </MudStack>
                </MudPaper>
            </MudStack>
        }

        @if (!string.IsNullOrWhiteSpace(_error))
        {
            <MudAlert Severity="Severity.Error" Dense="true">
                @_error
            </MudAlert>
        }

        <MudButton Variant="Variant.Filled" Color="Color.Primary"
                   Disabled="_isSubmitting" StartIcon="@Icons.Material.Filled.Send"
                   OnClick="@SubmitAsync">
            @(_isSubmitting ? "Skickar..." : "Skicka")
        </MudButton>
    </MudStack>
</MudPaper>

@implements IDisposable

@code {
    [Parameter]
    public EventCallback OnSubmitted { get; set; }

    [Inject]
    private HttpClient Http { get; set; } = default!;

    [Inject]
    private ISnackbar Snackbar { get; set; } = default!;

    [Inject]
    private UserIdentityService IdentityService { get; set; } = default!;

    private string? _lastQuery;
    private double _lastTopScore;

    private readonly MatchSubmissionDraft _model = new();
    private bool _isSubmitting;
    private string? _error;
    private bool _hasPrefilledIdentity;
    private string? _identityName;
    private List<Suggestion> _suggestions = new();
    private SubmissionMode _submissionMode = SubmissionMode.OutcomeOnly;
    private string _outcomeSetsInput = string.Empty;
    private static readonly CultureInfo SwedishCulture = CultureInfo.GetCultureInfo("sv-SE");

    protected override async Task OnInitializedAsync()
    {
        // Only initialize sets if we're in scored mode
        if (_submissionMode == SubmissionMode.Scored && _model.Sets.Count == 0)
        {
            for (var i = 0; i < 3; i++)
            {
                AddSet();
            }
        }
        
        // Förifyll spelare ett med identitet från localStorage
        await LoadIdentityAsync();
        
        // Subscribe to identity changes
        IdentityService.IdentityChanged += OnIdentityChanged;
        // await LoadSuggestionsAsync();
    }

    private async Task LoadIdentityAsync()
    {
        var identityName = await IdentityService.GetIdentityNameAsync();
        _identityName = identityName;
        if (string.IsNullOrWhiteSpace(_model.PlayerOne) && !_hasPrefilledIdentity)
        {
            if (!string.IsNullOrWhiteSpace(identityName))
            {
                _model.PlayerOne = identityName;
                _hasPrefilledIdentity = true;
            }
        }
    }

    private async void OnIdentityChanged(object? sender, EventArgs e)
    {
        // Only update if user hasn't manually changed PlayerOne
        if (_hasPrefilledIdentity && string.IsNullOrWhiteSpace(_model.PlayerOne))
        {
            var identityName = await IdentityService.GetIdentityNameAsync();
            _identityName = identityName;
            if (!string.IsNullOrWhiteSpace(identityName))
            {
                _model.PlayerOne = identityName;
                await InvokeAsync(StateHasChanged);
            }
        }
    }

    public void Dispose()
    {
        IdentityService.IdentityChanged -= OnIdentityChanged;
    }

    private async Task<IEnumerable<string?>> SearchPlayersAsync(string value, CancellationToken cancellationToken)
    {
        _lastQuery = value?.Trim();
        _lastTopScore = 0;
        if (string.IsNullOrWhiteSpace(_lastQuery) || _lastQuery!.Length < 2)
        {
            return Array.Empty<string?>();
        }

        var resp = await Http.GetFromJsonAsync<List<PlayerSuggestion>>($"/api/players?query={Uri.EscapeDataString(_lastQuery)}&size=10", cancellationToken);
        var items = resp ?? new List<PlayerSuggestion>();
        _lastTopScore = items.Count > 0 ? items[0].score : 0;
        var names = items.Select(i => i.displayName).ToList<string?>();
        if (names.Count == 0)
        {
            names.Add(" "); // placeholder item so popup opens and AfterItemsTemplate Add button is visible
        }
        return names;
    }

    private void AddSet()
    {
        var nextNumber = _model.Sets.Count + 1;
        _model.Sets.Add(new SetDraft(nextNumber));
    }

    private void OnSubmissionModeChanged(SubmissionMode mode)
    {
        if (_submissionMode == mode) return;
        
        _submissionMode = mode;
        if (_submissionMode == SubmissionMode.Scored && _model.Sets.Count == 0)
        {
            // Initialize sets when switching to scored mode
            for (var i = 0; i < 3; i++)
            {
                AddSet();
            }
        }
        else if (_submissionMode == SubmissionMode.OutcomeOnly)
        {
            // Clear sets when switching to outcome-only mode
            _model.Sets.Clear();
        }
        StateHasChanged();
    }


    private void RemoveSet()
    {
        if (_model.Sets.Count > 1)
        {
            _model.Sets.RemoveAt(_model.Sets.Count - 1);
        }
    }

    private async Task LoadSuggestionsAsync()
    {
        try
        {
            var me = _identityName;
            var url = string.IsNullOrWhiteSpace(me)
                ? "/api/suggestions/opponents?take=5"
                : $"/api/suggestions/opponents?me={Uri.EscapeDataString(me)}&take=5";
            var resp = await Http.GetFromJsonAsync<SuggestionsResponse>(url);
            _suggestions = resp?.items ?? new List<Suggestion>();
        }
        catch
        {
            _suggestions.Clear();
        }
        StateHasChanged();
    }

    private async Task SubmitAsync()
    {
        if (_isSubmitting) return;
        _error = null;
        StateHasChanged();

        var p1 = _model.PlayerOne?.Trim();
        var p2 = _model.PlayerTwo?.Trim();
        if (string.IsNullOrWhiteSpace(p1) || string.IsNullOrWhiteSpace(p2))
        {
            _error = "Båda spelarnamnen krävs.";
            return;
        }
        if (string.Equals(p1, p2, StringComparison.OrdinalIgnoreCase))
        {
            _error = "Spelarna måste vara olika.";
            return;
        }

        MatchSubmissionDto dto;
        var submitterName = await IdentityService.GetIdentityNameAsync();
        var submittedBy = string.IsNullOrWhiteSpace(submitterName) ? "anonym" : submitterName.Trim();

        if (_submissionMode == SubmissionMode.OutcomeOnly)
        {
                if (!TryParseOutcomeSets(_outcomeSetsInput, out var playerOneSets, out var playerTwoSets, out var parseError))
                {
                    _error = parseError;
                    return;
                }

                var playerOneWon = playerOneSets > playerTwoSets;
                var outcomeSets = BuildOutcomeSetDtos(playerOneSets, playerTwoSets);

            dto = (MatchSubmissionDto)new OutcomeOnlyMatchSubmissionDto(
                p1,
                p2,
                _model.MatchDate.HasValue ? DateOnly.FromDateTime(_model.MatchDate.Value) : DateOnly.FromDateTime(DateTime.UtcNow),
                playerOneWon,
                    Sets: outcomeSets,
                SubmittedBy: submittedBy);
        }
        else
        {
            if (_model.Sets.Count == 0)
            {
                _error = "Lägg till minst ett set.";
                return;
            }

            var sets = _model.Sets
                .Select(s => new SetScoreDto(s.PlayerOneScore, s.PlayerTwoScore))
                .ToList();

            dto = (MatchSubmissionDto)new ScoredMatchSubmissionDto(
                p1,
                p2,
                _model.MatchDate.HasValue ? DateOnly.FromDateTime(_model.MatchDate.Value) : DateOnly.FromDateTime(DateTime.UtcNow),
                sets,
                submittedBy);
        }

        try
        {
            _isSubmitting = true;
            StateHasChanged();
            var response = await Http.PostAsJsonAsync("/matches", dto);
            var body = await response.Content.ReadAsStringAsync();
            if (!response.IsSuccessStatusCode)
            {
                _error = $"Sändning misslyckades: {body}";
                Snackbar.Add(_error, Severity.Error);
                return;
            }

            Snackbar.Add("Match inskickad!", Severity.Success);
            await OnSubmitted.InvokeAsync();

            // Reset form but keep players for consecutive matches
            _model.Sets.Clear();
            _outcomeSetsInput = string.Empty;
            if (_submissionMode == SubmissionMode.Scored)
            {
                for (var i = 0; i < 3; i++) AddSet();
            }
        }
        catch (Exception ex)
        {
            _error = $"Oväntat fel: {ex.Message}";
            Snackbar.Add(_error, Severity.Error);
        }
        finally
        {
            _isSubmitting = false;
            StateHasChanged();
        }
    }

    private sealed class MatchSubmissionDraft
    {
        public string? PlayerOne { get; set; }

        public string? PlayerTwo { get; set; }

        public DateTime? MatchDate { get; set; } = DateTime.Today;

        public List<SetDraft> Sets { get; } = new();
    }

    private enum SubmissionMode
    {
        OutcomeOnly,
        Scored
    }

    private sealed class SetDraft
    {
        public SetDraft(int number)
        {
            Number = number;
        }

        public int Number { get; }

        public int PlayerOneScore { get; set; }

        public int PlayerTwoScore { get; set; }
    }
    private async Task AddNewPlayerAsync(bool isPlayerOne)
    {
        if (string.IsNullOrWhiteSpace(_lastQuery)) return;
        var payload = new PlayerCreate(_lastQuery!);
        var response = await Http.PostAsJsonAsync("/api/players", payload);
        response.EnsureSuccessStatusCode();
        var created = await response.Content.ReadFromJsonAsync<PlayerCreated>();
        if (created is null) return;
        if (isPlayerOne) _model.PlayerOne = created.displayName; else _model.PlayerTwo = created.displayName;
        Snackbar.Add($"La till spelare '{created.displayName}'", Severity.Success);
        StateHasChanged();
    }

    private async Task OnPlayerSelected(string? selection, bool isPlayerOne)
    {
        // Handle clearing
        if (string.IsNullOrWhiteSpace(selection))
        {
            if (isPlayerOne)
            {
                _model.PlayerOne = null;
                _hasPrefilledIdentity = false; // User intentionally cleared, don't auto-refill
            }
            else
            {
                _model.PlayerTwo = null;
            }
            return;
        }
        
        if (selection.Trim().Length == 0) return; // ignore placeholder
        
        // Detect synthetic add item
        if (selection.StartsWith("Lägg till '") && selection.EndsWith("'", StringComparison.Ordinal))
        {
            // re-use last query to create
            await AddNewPlayerAsync(isPlayerOne);
            return;
        }

        if (isPlayerOne) _model.PlayerOne = selection; else _model.PlayerTwo = selection;
    }

    private sealed record PlayerSuggestion(Guid id, string displayName, double score, bool isExact);
    private sealed record PlayerCreate(string DisplayName);
    private sealed record PlayerCreated(Guid id, string displayName);
    private sealed record Suggestion(Guid id, string displayName, int count);
    private sealed record SuggestionsResponse(List<Suggestion> items);

    private readonly record struct OutcomePreview(int PlayerOneSets, int PlayerTwoSets, string WinnerName);

    private bool TryGetOutcomePreview(out OutcomePreview preview)
    {
        preview = default;
        if (!TryParseOutcomeSets(_outcomeSetsInput, out var p1, out var p2, out _))
        {
            return false;
        }

        var winnerName = p1 > p2 ? (_model.PlayerOne ?? "Spelare ett") : (_model.PlayerTwo ?? "Spelare två");
        preview = new OutcomePreview(p1, p2, winnerName);
        return true;
    }

    private static List<SetWinnerDto> BuildOutcomeSetDtos(int playerOneSets, int playerTwoSets)
    {
        var sets = new List<SetWinnerDto>(playerOneSets + playerTwoSets);
        var p1 = playerOneSets;
        var p2 = playerTwoSets;
        var setNumber = 1;
        while (p1 > 0 || p2 > 0)
        {
            if (p1 > 0)
            {
                sets.Add(new SetWinnerDto(setNumber++, true));
                p1--;
            }

            if (p2 > 0)
            {
                sets.Add(new SetWinnerDto(setNumber++, false));
                p2--;
            }
        }

        return sets;
    }

    private static bool TryParseOutcomeSets(string? input, out int playerOneSets, out int playerTwoSets, out string? error)
    {
        playerOneSets = 0;
        playerTwoSets = 0;
        error = null;

        if (string.IsNullOrWhiteSpace(input))
        {
            error = "Ange setresultat, till exempel 2-1.";
            return false;
        }

        var normalized = input.Trim();
        var dashIndex = normalized.IndexOf('-', StringComparison.Ordinal);
        if (dashIndex <= 0 || dashIndex >= normalized.Length - 1)
        {
            error = "Använd formatet X-Y, exempelvis 2-1.";
            return false;
        }

        var left = normalized[..dashIndex].Trim();
        var right = normalized[(dashIndex + 1)..].Trim();
        if (!int.TryParse(left, NumberStyles.Integer, CultureInfo.InvariantCulture, out playerOneSets) ||
            !int.TryParse(right, NumberStyles.Integer, CultureInfo.InvariantCulture, out playerTwoSets))
        {
            error = "Setresultatet måste innehålla siffror, till exempel 3-1.";
            return false;
        }

        if (playerOneSets < 0 || playerTwoSets < 0)
        {
            error = "Antal set måste vara noll eller större.";
            return false;
        }

        if (playerOneSets == 0 && playerTwoSets == 0)
        {
            error = "Minst ett set måste vinnas.";
            return false;
        }

        if (playerOneSets == playerTwoSets)
        {
            error = "Setresultatet kan inte vara oavgjort.";
            return false;
        }

        return true;
    }
}
